======================================================================================
Codigo de capta (canalización de 3 etapas):

A). Hacer dos arreglos de tipo byte, uno de 2 bytes para guardar la instruccion y los registros origen y destino. El otro de 4 bytes para guardar el dato en caso que la instruccion sea de 6 bytes. Ponerlos de manera global (static).

B). Obtener el registro BP y el IP (que deben contener de 4 bytes c/u). Convertirlos a su representación  flotante y sumarlos para obtener la dirección de la RAM a partir de donde se van a leer los 6 bytes de la instruccion (siempre leeremos 6 independientemente si la instruccion mide 2 o 6), los dos primeros bytes ponerlos en el arreglo de 2 bytes, los 4 siguientes en el arreglo de 4 bytes. Esto es todo lo que hace el módulo de "capta" de la canalización de 3 etapas.

Primer arreglo (codigo de registro y direccion)
segundo arreglo (datos)

Traer lo del registro IP y BP convertirlos, sumarlos 
R[IP] = FADIC738 <-- Convertir a flotante, ambos = 357
R[BP] =                                          = 1000

Sumar los dos, osea, 1357, se lee a partier de la 1357 (ir a esa posicion en la RAM) SIEMPRE SE VAN A LEER 6 BYTES, los dos primeros se meten en el arreglo de 2 bytes y el resto 4 bytes se mete en el arreglo de 4 bytes.
	

======================================================================================
Código de traduce (canalización de 3 etapas): llena los 2 arreglos, trabajara con ellos
Siempre capta 6 bytes, ya estan los dos arreglos, ahora revisar bit x bit.
Los 3 primeros bits dicen mucho: 


A). Obtener el primer bit del byte de la instrucción, si bit=1 y la PSW[15] no es igual a true, desplegar mensaje de "Violacion de accesso al modo kernel" y abortar el programa (System.exit(4)).
Por que el primer bit indica si la instruccion es en modo kernel, si está prendido (1) así que solo se ejecuta si la PSW es == true, o sea da permiso. El bit indica como se quiere ejecutar, la PSW indica en que modo está. 
NO PASA NADA ne l resto de las combinaciones. Pra obtener el bit, leer el arreglo, rotarlo, hacerle un and, lo que sea necesario para obtenerlo

B). Si no hubo violación, convertir el primer byte del buffer de 2 bytes a entero ya que es el código de la instrucción, este valor entero meterlo en la variable "cod_inst". Ya que se tiene permiso, agarrar el primer byte, convertirlo , por ejemplo la instruccion 64 asignarla a cod_ins

C). Obtener el 2o. bit de instrucción (segura o insegura) y guardarlo (S=0 o bien S=1 dependiendo del bit).

D). Obtener el 3er. bit de longitud de la instrucción (L=0 o bien L=1 dependiendo del bit).

E). Calcular el largo de la instrucción con el bit anterior LARGO = 2 + L x 4  (nos da 2 o 6)

F). Si LARGO=6, entonces poner en la variable entera "dato" los 4 bytes del arreglo de 4 bytes (en representación entera), si LARGO no es 6, entonces no hacer nada, la variable dato se quedará con lo que alguna vez tuvo y no nos interesa.

G). Tomar el IP (que es de 4 bytes) convertirlo a flotante y sumarle el largo obtenido en E) (que puede ser 2 o 6).

H). Tomar el nuevo valor que tendrá IP calculado en G), convertirlo a 4 bytes y actualizar IP con ese valor.

I). Obtener el valor del registro OI (que son 4 bytes), convertirlo a un numero flotante, digamos "F".

J). Calcular el nuevo valor de OI mediante S x ( F + S x L ), este valor obtenido convertirlo a 4 bytes y almacenarlo como nuevo valor de OI.

K). Tomar el byte que corresponde a origen y destino (el segundo byte del arreglo de 2 bytes) y partirlo en 2 nibbles, el valor entero del primer nibble se mete a la variable "orig", y el valor entero del segundo nibble se mete a la variable "dest".

Esto es todo lo que hace el traductor de la canalización de 3 etapas. 



========================================================================

Implementar e que lee el binario.
En google drive está el menu, implementarlo e el nuestro

 

